
第二部分：DataFrame
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Pandas包提供了一种类似关系表的数据结构——DataFrame，这是
数据科学中最为广泛应用的数据结构之一。

DataFrame数据结构如下表:

+------+-------+-------------+----------------+
|      |name   |number       |Explicit indexes|
+------+-------+-------------+----------------+
|row   |index  |index.size   |index           |
|      |       |shape[0]     |                |
+------+-------+-------------+----------------+
|column|columns|columns.size |columns         |
|      |       |shape[1]     |                |
+------+-------+-------------+----------------+



2.1 DataFrame 的创建方法
-----------------------------

创建DataFrame常用直接定义或者导入定义，一般后者更为常用。

(1)直接定义
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

::

    import numpy as np
    import pandas as pd
    df1 = pd.DataFrame(np.arange(10).reshape(2,5))

df1 的输出结果:

+-+-+-+-+-+-+
| |0|1|2|3|4|
+-+-+-+-+-+-+
|0|0|1|2|3|4|
+-+-+-+-+-+-+
|1|5|6|7|8|9|
+-+-+-+-+-+-+


(2)导入定义
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

用pandas包导入一个外部文件时，自动转化为DataFrame对象。
Pandas提供了read_csv()方法，将外部csv文件读入本地数据框。::

    #以example1.csv文件为例
    df2 = pd.read_csv('example1.csv')

    #使用Fancy Indexing方法，选择投影到的数据框
    df2 = df2[['id','diagnosis','area_mean']]

    #当数据量很大时，我们没有必要查阅所有内容
    #可以用head()和tail()函数可以显示数据框的前几行和后几行
    df2.head()

输出结果为:

+-+--------+---------+---------+
| |id      |diagnosis|area_mean|
+-+--------+---------+---------+
|0|842302  |M        |1001.0   |
+-+--------+---------+---------+
|1|842517  |M        |1326.0   |
+-+--------+---------+---------+
|2|84300903|M        |1203.0   |
+-+--------+---------+---------+
|3|84348301|M        |386.1    |
+-+--------+---------+---------+
|4|84358402|M        |1297.0   |
+-+--------+---------+---------+

*结果为 example1.csv中的数据*



2.2 查看行或列
-----------------------------

::

    #查看行名
    df2.index
    
    #查看列名
    df2.columns

    #计算行数
    df2.index.size

    #计算列数
    df2.columns.size

::

    #同时显示行数和列数1
    df2.shape

    #同时显示行数和列数2
    print('行数为:', df2.shape[0])
    print('列数为:'，df2.shape[1])

*df2.shape的返回值是一个元组，元组的第一个值对应行数，第二个值对应列数*

2.3 引用行或列
-----------------------------

(1)引用下标
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

在python中，通过iloc来表达下标::

    df.iloc[1,2]

(2)按列名读取
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

::

    #1。列名作下标
    df2['id'].head()

    #2.列名作数据框的一个属性
    df2.id.head()

    #3.列名和行号一起用
    df2['id'][2]chan

    #4.属性名和行号一起用
    df2.id[2]

    #5.切片
    df2['id'][2,4]

(3)通过index访问元素
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

在python中，每个数据框有两种index，一种为自带或者默认，从0开始；
另一种通过index属性定义。

前者被称为隐式index，后者被成为显式index。显式由用户自行定义，可以是
1，2，3这样的整数。若为整数，可能与默认index产生混乱。

所以python引入了ioc，iloc，ix等属性。用ioc表示显式index；iloc表示隐式index；ix可混用。

如::

    #按index
    df2.loc[1,'id']

    #按隐式index
    df2.iloc[1,0]

    #.ix[]访问
    df2.ix[[1],['id']]
    #若系统提示 ".ix is deprecated. Please use .loc or .iloc"，
    #说明.ox属性不再使用，用.loc或.iloc代替。

    #按显式index访问非连续元素
    df2[['area_mean','id']].head()



2.4 index操作
-----------------------------

更改显式index的方法：用.reinindex()方法::

    df2.reindex(index = ['1'.'2','3'],columns = ['1','2','3'])
    #更改显式index的含义，是调整index的顺序

在重新索引时可以新增一个显式index::

    #新增一个index，名称是MyNewColumn
    df3 = df2.reindex(index = [2,3,1],columns = ['diagnosis','id','area_mean',
    'MyNewColumn'],fill_value = 100)

    df3

输出结果:

=== ========= ======== ========= ===========
|   diagnosis id       area_mean MyNewColumn
=== ========= ======== ========= ===========
2   M         84300903 1203.0    100
3   M         84348301 386.1     100
1   M         842517   1326.0    100
=== ========= ======== ========= ===========



2.5 删除或过滤行/列
-----------------------------

过滤某行/列::

    #使用drop()函数，过滤了第3行，则head()函数显示01345行
    df2.drop([2]).head()

*1.此处，下标2是显式 index!*

*2.drop()函数不会更改原对象本身!*

若要修改原对象::

    #此方法修改了原对象，所以要声明定义原对象，否则df2的当前值会一直变化
    #drop()函数有三个参数，第一个参数可以为列表或值
    df2.df2[['id','diagnosis','area_mean']]
    df2.drop([3,4], axis = 0, inplace = True)

*axis = 0 的含义有 1.计算前后的列数不变 2.以列为单位计算 3.逐列计算*

*inplace: 为 True，对原对象修改; 为 False，不修改本身，返回另一个对象。默认为 False*

删除列::

    #1.切片
    df2 = df2[['id','diagnosis','area_mean']]
    del df2['area_mean']

    #2.drop()
    df2.drop(['id','diagnosis'], axis = 1, inplace = True)

*两种方法都是对原对象修改*

过滤::

    #添加过滤条件
    df2[df2.area_mean>1000].head()

    #area_mean > 1000 且只显示id，diagnosis两列
    df2[df2.area_mean>1000][['id','diagnosis']].head()



2.6 算术运算
-----------------------------

数据框之间的计算规则——先补齐显式index，新增对应值为NaN得到相同结构后，再进行计算。

(1)利用算术运算符
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

::

    import numpy as np
    import pandas as pd
    df3 = pd.DataFrame(np.arrange(6).reshape(2,3))
    df4 = pd.DataFrame(np.arrange(10).reshape(2,5))
    
df3和df4分别为:

= = = =     
| 0 1 2     
0 0 1 2     
1 3 4 5     
= = = =    

= = = = = =
| 0 1 2 3 4
0 0 1 2 3 4
1 5 6 7 8 9
= = = = = =

相加运算::

    df3+df4

结果为:

= = == == === ===
| 0 1  2  3   4  
0 0 2  4  NaN NaN
1 8 10 12 NaN NaN
= = == == === ===

另外，当数据框与Series进行计算时，按行广播，一行一行计算，行内不足不做循环计算。

如::

    s1 = pd. Series(np.arange(3))
    df4-s1

结果为:

= === === ==== === ===
| 0   1   2    3   4  
0 0.0 0.0 0.0  NaN NaN
1 5.0 5.0 5.0  NaN NaN
= === === ==== === ===

当数据框与数值进行运算时，直接对框内每个数据进行计算。

如::

    df3+2

结果为:

= = = =
| 0 1 2
0 2 3 4
1 5 6 7
= = = =

(2)利用成员方法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

在数据分析项目中，一般不用运算符，而用对应的成员方法。

调用成员方法的灵活性比运算符高，在成员方法中也可以设置更多的参数。

如::

    df5 = df3.add(df4, fill_value = 10)
    df5

结果为:

= = == == ==== ====
| 0 1  2  3    4   
0 1 2  4  13.0 14.0
1 8 10 12 18.0 19.0
= = == == ==== ====

再如::

    #axis = 1，则运算为逐行运算
    df5.sub(s1, axis = 1)

结果为:

= === === === === ===
| 0   1   2   3   4  
0 0.0 0.0 0.0 NaN NaN
1 5.0 5.0 5.0 NaN NaN
= === === === === ===

*axis = 1意味着：1.计算前后行数不变 2.以行为单位计算 3.逐行计算*

(3)一些特别的成员方法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

1.rolling()会依次计算相邻几个元素之和::

    #默认情况下，按列计算，axis = 0
    df3.rolling(2).sum()

结果为:

= === === ===
| 0   1   2  
0 NaN NaN NaN
1 3.0 5.0 7.0
= === === ===

::

    #axis = 1, 按列计算
    df3.rolling(2, axis = 1).sum()


结果为:

= === === ===
| 0   1   2  
0 NaN 1.0 3.0
1 NaN 7.0 9.0
= === === ===

2.数学统计相关的成员方法::

    #协方差矩阵
    df4.cov()

    #相关系数矩阵
    df4.corr()

    #数据框的转置
    df4.T



2.7 大小比较运算
-----------------------------

把数据框与数值等数据直接比大小，会得到一个布尔值的数据框。

如:

    df3 > 1

    df3 > s1

结果分别为：

= ===== ===== =====
| 0     1     2
0 False False True
1 True  True  True
= ===== ===== =====

= ===== ===== =====
| 0     1     2
0 False False False
1 True  True  True
= ===== ===== =====



2.8 统计信息
-----------------------------

(1) describe()方法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

describe()方法是非常常用的描述性统计方法之一，仍以example1.csv为例

::

    df2 = pd.read_csv('example1.csv')
    df2 = df2[['id','diagnosis','area_mean']]
    df2.describe()

结果为:

====== ============== ============
|      id             area_mean
count  5.690000e+02   569.000000
mean   3.037183e+07   654.889104
std    1.250206e+08   351.914129
min    8.670000e+03   143.500000
25%    8.692180e+05   420.300000
50%    9.060240e+05   551.100000
75%    8.813129e+06   782.700000
max    9.112105e+08   2501.000000
====== ============== ============

*count为计数，mean为均值，std为标准差，min、25%、50%、75%、max为数据的从小到大的分布情况*

(2) 过滤方法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

把过滤条件写在“下标”中::

    #只查看diagnosis为M的项
    df2[df2.diagnosis=='M']

(3) 频次统计方法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

count()可以显示计数::

    df2.count()


2.9 排序
-----------------------------

(1) 按值排序
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

sort_value方法::

    #以area_mean值升序排列
    df2.sort_value(by = 'area_mean', axis = 0, ascending = True).head()

(2) 显式index排序
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

sort_index方法::

    #ascending不赋值，默认升序，逐行计算
    df2.sort_index(axis = 1)

    #逐列计算
    df2.sort_index(axis = 0)



2.10 导入/导出
-----------------------------

DataFrame 导入/导出的前提是要知道当前工作目录的位置。

如下方法可获取目录::

    import os
    print(os.getcwd())

导出方法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

用 .to_***()来导出相应格式::

    #csv格式
    df2.head(3).to_csv('example1.csv')

    #excel格式
    df2.head(3).to_excel('example2.xls')

导入方法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

.read_***()::

    #csv格式
    df3 = pd.read_csv('example1.csv')

    #excel格式
    df3 = pd.read_excel('example2.xls')

